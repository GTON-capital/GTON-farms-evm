{
  "language": "Solidity",
  "sources": {
    "contracts/CompoundStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/AddressArrayLibrary.sol\";\n\ncontract CompoundStaking is IERC20 {\n    string public name;\n    string public symbol;\n\n    address public owner;\n    \n    bool public revertFlag;\n    uint public totalShares;\n    uint public potentiallyMinted;\n    uint public lastRewardBlock;\n    uint public requiredBalance;\n    uint public blocksInYear;\n    uint public apyUp;\n    uint public apyDown;\n    uint public decimals;\n    address[] public lpAdmins;\n\n    struct UserInfo {\n        uint share;\n        uint tokenAtLastUserAction;\n    }\n\n    IERC20 public immutable token;\n    mapping(address => UserInfo) public userInfo;\n    mapping(address => mapping(address => uint)) public allowances;\n\n    constructor(\n        IERC20 _token,\n        uint _blocksInYear,\n        string memory _name,\n        string memory _symbol,\n        uint _apyUp,\n        uint _apyDown\n    ) {\n        owner = msg.sender;\n        token = _token;\n        blocksInYear = _blocksInYear;\n        lastRewardBlock = block.number;\n        decimals = token.decimals();\n        name = _name;\n        symbol = _symbol;\n        apyUp = _apyUp;\n        apyDown = _apyDown;\n    }\n\n    modifier notReverted() {\n        require(!revertFlag, \"Compound: reverted flag on.\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Compound: permitted to owner only.\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender==owner || AddressArrayLib.indexOf(lpAdmins, msg.sender) != -1, \"Compound: permitted to admins only\");\n        _;\n    }\n\n    event RevertFlag(bool flag);\n    event SetOwner(address oldOwner, address newOwner);\n    event SetApy(uint oldDown, uint oldUp, uint newDown, uint newUp);\n    event SetBlockInYear(uint oldBlocksInYear, uint newBlocksInYear);\n    \n    function totalSupply() public view returns (uint256) {\n        uint tokenPerBlock = apyUp * requiredBalance / apyDown / blocksInYear;\n        uint delta = block.number - lastRewardBlock;\n        uint potentialMint = delta * tokenPerBlock;\n        return requiredBalance+potentialMint;\n    }\n\n    function balanceOf(address _user) public view returns(uint) {\n        if(totalShares <= 0) return 0;\n        return userInfo[_user].share * totalSupply() / totalShares;\n    }\n\n    function shareToBalance(uint _share) public view returns(uint) { \n        return _share * requiredBalance / totalShares;\n    }\n\n    function balanceToShare(uint _balance) public view returns(uint) { \n        return _balance * totalShares / requiredBalance;\n    }\n\n    function setAdmins(address[] memory admins) public onlyOwner {\n        for(uint i = 0; i < admins.length; i++) {\n            lpAdmins.push(admins[i]);\n        }\n    }\n\n    function removeAdmins(address[] memory admins) public onlyOwner {\n        for(uint i = 0; i < admins.length; i++) {\n            AddressArrayLib.removeItem(lpAdmins, admins[i]);\n        }\n    }\n\n    function setApy(uint _apyUp, uint _apyDown) public onlyAdmin {\n        uint oldDown = apyDown;\n        uint oldUp = apyUp;\n        apyUp = _apyUp;\n        apyDown = _apyDown;\n        emit SetApy(oldDown, oldUp, _apyDown, _apyUp);\n    }\n\n    function setBlocksInYear(uint _blocksInYear) public onlyAdmin {\n        updateRewardPool();\n        uint oldBlocksInYear = blocksInYear;\n        blocksInYear = _blocksInYear;\n        emit SetBlockInYear(oldBlocksInYear, _blocksInYear);\n    }\n\n    function toggleRevert() public onlyOwner {\n        revertFlag = !revertFlag;\n    }\n\n    function withdrawToken(IERC20 _token, address _to, uint _amount) public onlyOwner {\n            require(_token.transfer(_to,_amount));\n    }\n\n    function transferOwnership(address _owner) public onlyOwner {\n        address oldOwner = owner;\n        owner = _owner;\n        emit SetOwner(oldOwner, _owner);\n    }\n\n    function allowance(address _owner, address spender) external view returns (uint256) {\n        return allowances[_owner][spender];\n    }\n\n    function _approve(\n        address _owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    function approve(address spender, uint amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint amount\n    ) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint transferShare = balanceToShare(amount);\n        require(userInfo[sender].share >= transferShare, \"ERC20: transfer amount exceeds balance\");\n        userInfo[sender].share -= transferShare;\n        userInfo[recipient].share += transferShare;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferShare(\n        address to,\n        uint share\n    ) public {\n        require(userInfo[msg.sender].share >= share, \"insufficent balance\");\n        userInfo[msg.sender].share -= share;\n        userInfo[to].share += share;\n        userInfo[msg.sender].tokenAtLastUserAction = balanceOf(msg.sender);\n        userInfo[to].tokenAtLastUserAction = balanceOf(to);\n    }   \n\n    function transferFrom(\n        address spender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(spender, recipient, amount);\n        uint256 currentAllowance = allowances[spender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(spender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    function updateRewardPool() public {\n        uint tokenPerBlock = apyUp * requiredBalance / apyDown / blocksInYear;\n        uint delta = block.number - lastRewardBlock;\n        uint potentialMint = delta * tokenPerBlock;\n        potentiallyMinted += potentialMint;\n        requiredBalance += potentialMint;\n        lastRewardBlock = block.number;\n    }\n\n    function mint(uint _amount, address _to) external {\n        updateRewardPool();\n        require(_amount > 0, \"Compound: Nothing to deposit\");\n        require(token.transferFrom(msg.sender,address(this),_amount),\"\");\n        uint256 currentShares = 0;\n        if (totalShares != 0) {\n            currentShares = _amount * totalShares / requiredBalance;\n        } else {\n            currentShares = _amount;\n        }\n        totalShares += currentShares;\n        requiredBalance += _amount;\n        UserInfo storage user = userInfo[_to];\n        user.share += currentShares;\n        user.tokenAtLastUserAction = balanceOf(_to);\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    function burn(address _to, uint256 _share) public {\n        updateRewardPool();\n        require(_share > 0, \"Compound: Nothing to burn\");\n\n        UserInfo storage user = userInfo[msg.sender];\n        require(_share <= user.share, \"Compound: Withdraw amount exceeds balance\");\n        uint256 currentAmount = requiredBalance * _share / totalShares;\n        user.share -= _share;\n        totalShares -= _share;\n        requiredBalance -= currentAmount;\n        user.tokenAtLastUserAction = balanceOf(msg.sender);\n        require(token.transfer(_to,currentAmount),\"Compound: Not enough token to transfer\");\n        emit Transfer(_to, address(0), currentAmount);\n    }\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint256);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n"
    },
    "contracts/libraries/AddressArrayLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n\nlibrary AddressArrayLib {\n\n    function removeItem(\n        address[] storage array,\n        address a\n    ) internal {\n        int i = indexOf(array, a);\n        require(i != -1, \"ARRAY_LIB: Element doesn't exist\");\n        remove(array, uint(i));\n    }\n\n    function remove(      \n        address[] storage array,\n        uint index\n    ) internal {\n        require(index <= array.length, \"ARRAY_LIB: Index does not exist\");\n        array[index] = array[array.length-1];\n        array.pop();\n    }\n\n\n    // probably not the best way to find index\n    function indexOf(\n        address[] storage array,\n        address a\n    ) internal view returns (int) {\n        if (array.length == 0) return int(-1); // we want to continue txn process\n        for(uint i=0; i<array.length; i++) {\n            if (array[i] == a) {\n                return int(i);\n            }\n        }\n        return int(-1);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}